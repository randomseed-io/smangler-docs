<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Splitting</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" type="text/css" href="css/randomseed.css" /></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Smangler</span> <span class="project-version">1.0.4</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="splitting.html"><div class="inner"><span>Splitting</span></div></a></li><li class="depth-1 "><a href="trimming.html"><div class="inner"><span>Trimming</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>smangler</span></div></div></li><li class="depth-2 branch"><a href="smangler.api.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>api</span></div></a></li><li class="depth-2"><a href="smangler.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#splitting" id="splitting"></a>Splitting</h1>
<p>Splitting strings into substrings is realized by these 3 API functions:</p>
<ul>
<li><a href="smangler.api.html#var-all-prefixes"><code>all-prefixes</code></a>,</li>
<li><a href="smangler.api.html#var-all-suffixes"><code>all-suffixes</code></a></li>
<li><a href="smangler.api.html#var-all-subs"><code>all-subs</code></a>.</li>
</ul>
<h2><a href="#getting-all-prefixes" id="getting-all-prefixes"></a>Getting all prefixes</h2>
<p>To get all possible prefixes of the given string you can call <code>all-prefixes</code> function from the API. In its basic form, it takes one argument which should be a string and returns a lazy sequence of strings, including the original string in the last position:</p>
<pre><code class="language-clojure">(require '[smangler.api :as sa])

(sa/all-prefixes       "")  ; =&gt; nil
(sa/all-prefixes "abcdef")  ; =&gt; ("a" "ab" "abc" "abcd" "abcde" "abcdef")
(sa/all-prefixes      "a")  ; =&gt; ("a")
</code></pre>
<h2><a href="#coercion-to-strings" id="coercion-to-strings"></a>Coercion to strings</h2>
<p>You can pass other types of arguments and they will be coerced to strings. Single characters and numbers are supported, and so are collections of strings, characters and numbers:</p>
<pre><code class="language-clojure">(require '[smangler.api :as sa])

(sa/all-prefixes        12345)  ; =&gt; ("1" "12" "123" "1234" "12345")
(sa/all-prefixes           \a)  ; =&gt; ("a")
(sa/all-prefixes      [0 1 2])  ; =&gt; ("0" "01" "012")
(sa/all-prefixes   [\a \b \c])  ; =&gt; ("a" "ab" "abc")
(sa/all-prefixes ["abc" "de"])  ; =&gt; ("a" "ab" "abc" "abcd" "abcde")
</code></pre>
<h2><a href="#custom-splitter" id="custom-splitter"></a>Custom splitter</h2>
<p>Optionally, you can call <code>all-prefixes</code> with 2 arguments passed. In this scenario the first argument should be a function which takes a single character and returns a character, <code>false</code> or <code>nil</code>:</p>
<pre><code class="language-clojure">(fn [character]
  (and (some-lookup character) character)
</code></pre>
<p>The function is used to partition the string. As a result the prefixes will not be generated for all characters but for those substrings which are the effect of splitting the string each time the splitter returns a new value.</p>
<pre><code class="language-clojure">(require '[smangler.api :as sa])

(sa/all-prefixes #(and (= \a %) %)
                 "abcdef")  ; =&gt; ("a" "abcdef")
</code></pre>
<h3><a href="#sets-as-splitters" id="sets-as-splitters"></a>Sets as splitters</h3>
<p>It is common to use sets for partitioning the string. This is possible because in Clojure sets implement function interface which allows us to perform quick lookup:</p>
<pre><code class="language-clojure">(require '[smangler.api :as sa])

(sa/all-prefixes #{\a \b} "abcdef")  ; =&gt; ("a" "ab" "abcdef")
(sa/all-prefixes #{\a}    "abcdef")  ; =&gt; ("a" abcdef")
</code></pre>
<h3><a href="#coercion-to-splitter" id="coercion-to-splitter"></a>Coercion to splitter</h3>
<p>You can pass other types of arguments and they will be coerced to splitters. Single characters, strings and numbers are supported, and so are collections of strings, characters and numbers:</p>
<pre><code class="language-clojure">(require '[smangler.api :as sa])

(sa/all-prefixes \a        "abcde")  ; =&gt; ("a" "abcde")
(sa/all-prefixes 1         "abcde")  ; =&gt; ("abcde")
(sa/all-prefixes 12      "12abcde")  ; =&gt; ("1" "12" "12abcde")
(sa/all-prefixes [1 2]   "12abcde")  ; =&gt; ("1" "12" "12abcde")
(sa/all-prefixes [\a \b]   "abcde")  ; =&gt; ("a" "ab" "abcde")
(sa/all-prefixes "ab"      "abcde")  ; =&gt; ("a" "ab" "abcde")
</code></pre>
<h2><a href="#getting-all-suffixes" id="getting-all-suffixes"></a>Getting all suffixes</h2>
<p>Getting all suffixes is possible with <a href="smangler.api.html#var-all-suffixes"><code>all-suffixes</code></a>. It takes the same arguments and returns the same kind of values as <code>all-prefixes</code> but (as the name stands for) generates all possible suffixes for the given string:</p>
<pre><code class="language-clojure">(require '[smangler.api :as sa])

(sa/all-suffixes                "")  ; =&gt; nil
(sa/all-suffixes          "abcdef")  ; =&gt; ("abcdef" "bcdef" "cdef" "def" "ef" "f")
(sa/all-suffixes               "a")  ; =&gt; ("a")

(sa/all-suffixes             12345)  ; =&gt; ("12345" "2345" "345" "45" "5")
(sa/all-suffixes                \a)  ; =&gt; ("a")
(sa/all-suffixes           [0 1 2])  ; =&gt; ("012" "12" "2")
(sa/all-suffixes        [\a \b \c])  ; =&gt; ("abc" "bc" "c")
(sa/all-suffixes      ["abc" "de"])  ; =&gt; ("abcde" "bcde" "cde" "de" "e")

(sa/all-suffixes  #(and (= \a %) %)
                    "abcdef")        ; =&gt; ("abcdef" "bcdef")

(sa/all-suffixes #{\a \b} "abcdef")  ; =&gt; ("abcdef" "bcdef" "cdef")
(sa/all-suffixes #{\a}    "abcdef")  ; =&gt; ("abcdef" "bcdef")

(sa/all-suffixes \a        "abcde")  ; =&gt; ("abcde" "bcde")
(sa/all-suffixes 1         "abcde")  ; =&gt; ("abcde")
(sa/all-suffixes 12      "12abcde")  ; =&gt; ("12abcde" "2abcde" "abcde")
(sa/all-suffixes [1 2]   "12abcde")  ; =&gt; ("12abcde" "2abcde" "abcde")
(sa/all-suffixes [\a \b]   "abcde")  ; =&gt; ("abcde" "bcde" "cde")
(sa/all-suffixes "ab"      "abcde")  ; =&gt; ("abcde" "bcde" "cde")
</code></pre>
<h2><a href="#getting-all-substrings" id="getting-all-substrings"></a>Getting all substrings</h2>
<p>You can get all possible substrings of a string by calling <a href="smangler.api.html#var-all-subs"><code>all-subs</code></a> from <a href="smangler.api.html"><code>smangler.api</code></a>. It works similarly to <code>all-prefixes</code> and <code>all-suffixes</code> but returns all prefixes, infixes and suffixes, including the original string:</p>
<pre><code class="language-clojure">(require '[smangler.api :as sa])

(sa/all-subs                "")  ; =&gt; nil
(sa/all-subs             "abc")  ; =&gt; ("a" "ab" "b" "abc" "bc" "c")
(sa/all-subs               "a")  ; =&gt; ("a")

(sa/all-subs               123)  ; =&gt; ("1" "12" "2" "123" "23" "3")
(sa/all-subs                \a)  ; =&gt; ("a")
(sa/all-subs           [0 1 2])  ; =&gt; ("0" "01" "1" "012" "12" "2")
(sa/all-subs        [\a \b \c])  ; =&gt; ("a" "ab" "b" "abc" "bc" "c")
(sa/all-subs        ["ab" "c"])  ; =&gt; ("a" "ab" "b" "abc" "bc" "c")

(sa/all-subs  #(and (= \a %) %)
              "abc")             ; =&gt; ("a" "abc" "bc")

(sa/all-subs #{\a \b}    "abc")  ; =&gt; ("a" "ab" "b" "abc" "bc" "c")
(sa/all-subs #{\a}       "abc")  ; =&gt; ("a" "abc" "bc")

(sa/all-subs \a          "abc")  ; =&gt; ("a" "abc" "bc")
(sa/all-subs 1           "abc")  ; =&gt; ("abc")
(sa/all-subs 12          "12c")  ; =&gt; ("1" "12" "2" "12c" "2c" "c")
(sa/all-subs [1 2]       "12c")  ; =&gt; ("1" "12" "2" "12c" "2c" "c")
(sa/all-subs [\a \b]     "abc")  ; =&gt; ("a" "ab" "b" "abc" "bc" "c")
(sa/all-subs "ab"        "abc")  ; =&gt; ("a" "ab" "b" "abc" "bc" "c")
</code></pre>
<h2><a href="#low-level-splitting" id="low-level-splitting"></a>Low-level splitting</h2>
<p>Certain applications may require more efficient and/or more strict splitting functions. It is particularly not recommended but there is <a href="smangler.core.html"><code>smangler.core</code></a> namespace which contains splitting operations which are a bit faster than those in API. They require certain argument types and no coercion is performed:</p>
<ul>
<li><a href="smangler.core.html#var-all-prefixes"><code>all-prefixes</code></a>,</li>
<li><a href="smangler.core.html#var-all-suffixes"><code>all-suffixes</code></a></li>
<li><a href="smangler.core.html#var-all-subs"><code>all-subs</code></a>.</li>
</ul>
<pre><code class="language-clojure">(require '[smangler.core :as c])

(c/all-prefixes          nil)  ; =&gt; nil
(c/all-prefixes           "")  ; =&gt; nil
(c/all-prefixes        "abc")  ; =&gt; ("a" "ab" "abc")
(c/all-prefixes  #{\a} "abc")  ; =&gt; ("a" "abc")

(c/all-suffixes          nil)  ; =&gt; nil
(c/all-suffixes           "")  ; =&gt; nil
(c/all-suffixes        "abc")  ; =&gt; ("abc" "bc" "c")
(c/all-suffixes  #{\a} "abc")  ; =&gt; ("abc" "bc")

(c/all-subs              nil)  ; =&gt; nil
(c/all-subs               "")  ; =&gt; nil
(c/all-subs            "abc")  ; =&gt; ("a" "ab" "b" "abc" "bc" "c")
(c/all-subs      #{\a} "abc")  ; =&gt; ("a" "abc" "bc")
</code></pre>
</div></div></div></body></html>